
//	FOS Mapper
/*	Переводим контент сервера на новую ревизию.
	
#Mk2@Convert::Map klamath
#Mk2@Convert::Map e_cave0_in
#Mk2@Convert::Map inst_raiders04-2 // - Dump
#Mk2@Convert::CrType 500
#Mk2@Convert::AllMaps D:/FalloutOnline/Server/maps/*.fomap
#Mk2@Convert::AllMaps D:/FalloutOnline/Server/maps/*klamath*.fomap
#Mk2@Convert::SetMapsListingPosition
#Mk2@Convert::ResumeAllMaps D:/FalloutOnline/Server/maps/*.fomap
*/

/*
// ToDo Items:
// New Revision:
#pragma property Item Public float FlyEffectSpeed

#pragma property Item Public uint8[] BlockLines

#pragma property Item Public uint8 Info

#pragma property Item PrivateServer hash ScriptId

#pragma property Item PrivateServer int TriggerNum
*/

// Files:
const 	::string DirectoryResource     = "D:/FalloutOnline_new/Modules/Mk2/Resources/Client/"; 
const 	::string DirectoryOutItems     = "D:/FalloutOnline_new/Modules/Mk2/Items/"; 
const 	::string DirectoryOutMaps      = "D:/FalloutOnline_new/Modules/Mk2/Maps/"; 
const 	::string DirectoryOldMaps      = "D:/FalloutOnline/Server/maps/";
 
const 	::string ContentFileItems      = "Mk2Content.fos"; 
const 	::string ContentFileMaps       = "Mk2Content.fos"; 

const 	::string MSGFileOldObjectRuss  = "D:/FalloutOnline/Server/text/russ/FOOBJ.MSG"; 
const 	::string MSGFileOldObjectEngl  = "D:/FalloutOnline/Server/text/engl/FOOBJ.MSG"; 

const 	::string CashFileName	       = DirectoryOutItems + "ConvertCash.info"; 

// ToDo:
const 	::string ItemsPropertyFile     = "D:/FalloutOnline_new/Modules/Mk2/ItemsProperty.fos";
funcdef ::string CheckItemProperty( ::ProtoItem@ proto ); 

// Real ListingContent:
::dictionary			__ListingContent;
  bool 					__IsContentInitialize = false;
::file 					__CashFile;

::string				__MSGObjectRuss = "";
::string				__MSGObjectEngl = "";

void InitializeContent( )
{
	if( __IsContentInitialize )
		return;
	
	__IsContentInitialize = true;
	
	// Это уже перенесенный контент, регистрируется для того чтобы не перезатирало.
	int defaultContent = Convert::ContextType::ContextScenery;
	// --------------------------------     Формат      ------------------------------------ //
	// ------- Pid ------------------------------- Content Name -------------- Type -------- //
	@ Content[ "4012" ] 	 = Convert::Context( "ScrollBlock"				, defaultContent );
	@ Content[ "5622" ] 	 = Convert::Context( "WallLight"				, defaultContent );
	@ Content[ "2049" ]		 = Convert::Context( "ExitGrid"					, defaultContent );
	@ Content[ "3853" ] 	 = Convert::Context( "Entrance"					, defaultContent );
	@ Content[ "2141" ] 	 = Convert::Context( "Light"					, defaultContent );
	@ Content[ "3852" ] 	 = Convert::Context( "Trigger"					, defaultContent );
	@ Content[ "15670"] 	 = Convert::Context( "BlockLight"				, defaultContent );
	@ Content[ "2067" ]		 =  
	@ Content[ "14112"]		 = Convert::Context( "MinimapInvisibleBlock"	, defaultContent );
	
	// Карты, используется например для энтайров. Нету необходимости переносить этот контент перед регистрацией.
	defaultContent = Convert::ContextType::ContextMap;
	// --------------------------------     Формат      ------------------------------------ //
	// ------- Pid ------------------------------- Content Name -------------- Type -------- //
	@ Content[ "MapPid_8"  ] = Convert::Context( "KlamathCanyon"  			, defaultContent );
	@ Content[ "MapPid_9"  ] = Convert::Context( "Klamath"		 			, defaultContent );
	@ Content[ "MapPid_11" ] = Convert::Context( "KlamathToilet"	 		, defaultContent );
	@ Content[ "MapPid_10" ] = Convert::Context( "KlamathMall"	 			, defaultContent );
	@ Content[ "MapPid_13" ] = Convert::Context( "KlamathTrap"	 			, defaultContent );
	@ Content[ "MapPid_14" ] = Convert::Context( "KlamathGraz"	 			, defaultContent );
	@ Content[ "MapPid_81" ] = Convert::Context( "KlamathRatcv1"	 		, defaultContent );
	@ Content[ "MapPid_82" ] = Convert::Context( "KlamathRatcv2"	 		, defaultContent );
	@ Content[ "MapPid_83" ] = Convert::Context( "KlamathRatcv3"	 		, defaultContent );
	@ Content[ "MapPid_211"] = Convert::Context( "ReplBankKlamath"			, defaultContent );
	
	// Криттеры, уже перенесенный контент криттеров, карты будут конвертировать только уже перенесенных криттеров.
	defaultContent = Convert::ContextType::ContextCritter;
	// --------------------------------     Формат      ------------------------------------ //
	// ------- Pid ------------------------------- Content Name -------------- Type -------- //
	@ Content["Critter_52"]  = Convert::Context( "ChildrenMale"	 			, defaultContent );
	@ Content["Critter_53"]  = Convert::Context( "ChildrenFemale" 			, defaultContent );
	
	::file contentFile;
	if( contentFile.open( "content.txt", "r") == 0 )
	{
		::string str = "";
		contentFile.readString( uint( contentFile.getSize( ) ), str );
		contentFile.close();
		
		::array<::string@> allLines = ::splitEx( str, "\n" );
		::array<::string@> words;
		str = "";

		for( uint i = 0, iEnd = allLines.length(); i < iEnd; i++ )
		{
			if( @allLines[i] !is null)
			{
				words = ::splitEx( allLines[i], " " );
				if( words.length() == 3 )
				{
					::StrToInt( words[2], defaultContent );
					@ Content[words[0]]  = Convert::Context( words[1], defaultContent );
				}
			}
		}
	}
	
	if( __CashFile.open( CashFileName, "r") == 0 )
	{
		::string str = "";
		__CashFile.readString( uint( __CashFile.getSize( ) ), str );
		__CashFile.close();
		
		::array<::string@> allLines = ::splitEx( str, "\n" );
		::array<::string@> words;
		str = "";

		for( uint i = 0, iEnd = allLines.length(); i < iEnd; i++ )
		{
			if( @allLines[i] !is null)
			{
				words = ::splitEx( allLines[i], " " );
				if( words.length() == 3 )
				{
					::StrToInt( words[2], defaultContent );
					@ Content[words[0]]  = Convert::Context( words[1], defaultContent );
				}
			}
		}
	}
	
	::file msgFile;
	if( msgFile.open( MSGFileOldObjectRuss, "r") == 0 )
	{
		msgFile.readString( uint( msgFile.getSize( ) ), __MSGObjectRuss );
		msgFile.close();
	}
	if( msgFile.open( MSGFileOldObjectEngl, "r") == 0 )
	{
		msgFile.readString( uint( msgFile.getSize( ) ), __MSGObjectEngl );
		msgFile.close();
	}
}

// Virtual Content: 
bool IsContent( ::string&in index )
{
	return __ListingContent.exists( index );
}

bool IsContentName( ::string&in index )
{
	Convert::Context@ checkContext = null;
	::array<::string@> keys;
	// ::strlwr(oldName)
	::string smallIndex = ::strlwr(index);
	for( uint i = 0, iEnd = __ListingContent.keys( keys ); i < iEnd; i++ )
	{
		@ checkContext = null;
		__ListingContent.get( keys[i], @checkContext );
		if( @ checkContext !is null  && ::strlwr(checkContext.Name) == smallIndex )
			return true;
	}
	return false;
}

Context@ set_Content( ::string&in index, Convert::Context@ value )
{
	if( @value !is null && __CashFile.getPos() != -1 )
	{
		__CashFile.writeString( index + " " + value.Name + " " + value.Type + "\n" );
	}
	__ListingContent.set( index, value );
	return value;
}

Context@ get_Content( ::string&in index )
{
	if( IsContent( index ) )
	{
		Convert::Context@ retValue = null;
		__ListingContent.get( index, @retValue );
		return retValue;
	}
	return null;
}

enum ContextType
{
	ContextNone 		= -2,
// File context:
	ContextMapFile 		= -1,

// Engine:
	ContextCritter 		= 0,
	ContextItem 		= 1,
	ContextScenery 		= 2,
	
// Custom:
	ContextMap		 	= 10,
	ContextLocation 	= 11,
	ContextCritterParam	= 12
}

enum TypeCheckProperty
{
// Primal:
	CheckBool 		= 0,
	CheckDigital	= 1,
	CheckString		= 2, // NoUse
	CheckCustom		= 3
}

class Color
{
	Color( ::string r, 
		   ::string g,
		   ::string b  )
	{
			  R = r;
			  G = g;
			  B = b;
	}

	::string 	  R;
	::string 	  G;
	::string 	  B;
}

class Context
{
	Context( ::string@ name, int type, ::file@ content = null, ::string@ section = null )
	{
		@Name = name;
		Type = type;
		
		ObjectId = 0;
		X = 0;
		Y = 0;
		@ ContentFile = content;
		
		@_CurrentObject = null;
		if( section! is null )
			CurrentSection = section;
		else
			CurrentSection = "";
		CurrentObjectType = Convert::ContextType::ContextNone;
		ContainerUID = 0;
	}
	
	void WriteSection( ::file&inout outFile, Convert::Context& map )
	{		
		switch( Type )
		{
		case Convert::ContextType::ContextItem:
		case Convert::ContextType::ContextScenery:
			{
				outFile.writeString("\n[Item]\n");
				outFile.writeString("$Id = " + ( ObjectId ) + "\n");
				outFile.writeString("$Proto = " + ( Name ) + "\n");
				
				if(map.UIDMemmory.exists( ""+ContainerUID ))
				{
					Convert::Context@ obj = null;
					map.UIDMemmory.get( ""+ContainerUID, @obj );
					if( @obj !is null )
					{							
						switch( obj.Type )
						{
						case Convert::ContextType::ContextItem:
							{
								outFile.writeString("Accessory = ItemContainer\n");
								outFile.writeString("ContainerId = " + obj.ObjectId + "\n");
							} break;
							
						case Convert::ContextType::ContextCritter:
							{
								outFile.writeString("Accessory = CritterInventory\n");
								outFile.writeString("CritId = " + obj.ObjectId + "\n");
							} break;
							
						default: break;
						}
						
					}
				}
				else
				{
					outFile.writeString("Accessory = MapHex\n");
					outFile.writeString("HexX = " + X + "\n");
					outFile.writeString("HexY = " + Y + "\n");
				}
			} break;
		case Convert::ContextType::ContextCritter:
			{
				outFile.writeString("\n[Critter]\n");
				outFile.writeString("$Id = " + ( ObjectId ) + "\n");
				outFile.writeString("$Proto = " + ( Name ) + "\n");
				outFile.writeString("HexX = " + X + "\n");
				outFile.writeString("HexY = " + Y + "\n");
			} break;
			
		default: break;
		}
		
		outFile.writeString( CurrentSection );
		
		for( uint i = 0, iEnd = AllContext.length(); i < iEnd; i++ )
		{
			if( @AllContext[i] !is null )
				AllContext[i].WriteSection( outFile, map );
		}
	}
	
	void refreshObject( int type )
	{
		// AllContext
		if( validCurrentObject )
		{
			AllContext.insertLast( @_CurrentObject );
		}
		
		@ _CurrentObject = null;
		_CurrentObjectType = type;
	}
	
//  Property:
//  virtual bool validCurrentObject
	bool get_validCurrentObject()
	{
		return ( @ _CurrentObject !is null );
	}
	
//  virtual int CurrentObjectType
	int get_CurrentObjectType()
	{
		if( validCurrentObject )
		{
			return _CurrentObject.Type;
		}
		return _CurrentObjectType;
	}
		
	int set_CurrentObjectType( int value )
	{
		if( validCurrentObject )
		{
			_CurrentObject.Type = value;
		}
		else _CurrentObjectType = value;
		return value;
	}
		
//  virtual Context@ CurrentObject
	Convert::Context@ set_CurrentObject( Convert::Context@ proto )
	{
		@ _CurrentObject = null;
		if( @proto !is null )
		{
			@ _CurrentObject = Convert::Context( proto.Name, CurrentObjectType, proto.ContentFile );
			_CurrentObject.ObjectId = --this.ObjectId;
		}
		
		return _CurrentObject;
	}
	
		
	Convert::Context@ get_CurrentObject( )
	{
		return _CurrentObject;
	}
	
	private int 		_CurrentObjectType;
	private Convert::Context@ 	_CurrentObject;
	
//  public:
	::file@ 				ContentFile;
	
	uint 				ProtoId;
	uint 				ObjectId;
	uint 				ContainerUID;
	uint 				X;
	uint 				Y;
	::array<::array<uint>> 			TilesCount;
	
	int 				Type;
	
	::array<Convert::Color@> 			DayColors;
	
	Convert::Context@[] 			AllContext;
	
	::string@ 			Name;
	::string 				CurrentSection;
	
	::dictionary 			UIDMemmory;
	
	// ToDo:
	::dictionary 			Property;
}

::string ConvertWord( ::string inStr )
{
	::string outStr = "";
	
	bool isWordStart = false;
	for( uint i = 0, iEnd = inStr.length(); i < iEnd; i++ )
	{
		if( inStr[i] == ' ' || inStr[i] == '-' || inStr[i] == '.' || inStr[i] == '+' || inStr[i] == '(' || inStr[i] == ')' || inStr[i] == '!' || inStr[i] == 39 ) // 39 == '
			inStr[i] = '_';
		else if( !isWordStart )
		{
			if( inStr[i]>=0x30 && inStr[i]<=0x39)
				inStr[i] = '_';
			else isWordStart = true;
		}
	}
	
	::array<::string@> words = ::splitEx( inStr, "_" );
	::string letter = " ";
	for( uint i = 0, iEnd = words.length(); i < iEnd; i++ )
	{
		if( words[i].length() > 0 )
		{
			letter[0] = words[i][0];
			letter = ::strupr( letter );
			words[i][0] = letter[0];
			outStr = outStr + words[i];
		}
	}
	return outStr;
}

::string GetProtoItemTypeName( ::ProtoItem@ protoItem )
{
	switch( protoItem.Type )
	{
	case ITEM_TYPE_GRID: return "Grid";
	case ITEM_TYPE_GENERIC: return "Generic";
	case ITEM_TYPE_WALL: return "Wall";
	case ITEM_TYPE_ARMOR: return "Armor";
	case ITEM_TYPE_DRUG: return "Drug";
	case ITEM_TYPE_WEAPON: return "Weapon";
	case ITEM_TYPE_AMMO: return "Ammo";
	case ITEM_TYPE_MISC:
	case ITEM_TYPE_MISC2: return "Misc";
	case ITEM_TYPE_KEY: return "Key";
	case ITEM_TYPE_CONTAINER: return "Container";
	case ITEM_TYPE_DOOR: return "Door";
	case ITEM_TYPE_CAR: return "Car";
	case ITEM_TYPE_NONE:
	default:
		return "none";
	}
	return "none";
}

void IntegerWriteItemProp( int prop, ::string&in str, ::file&inout contFile/*, int defValue = 0*/ )
{
	//if( prop != defValue )
		contFile.writeString( str + " = " + prop + "\n" );
}

void BoolWriteItemProp( bool prop, ::string&in str, ::file&inout contFile/*, bool defValue = false */)
{
	if( prop  )
		contFile.writeString( str + " = True\n" );
	else contFile.writeString( str + " = False\n" );
}

bool ConvertProtoItem( ::ProtoItem@ protoItem, Context@&inout retCtx )
{
	::string typeStr = GetProtoItemTypeName( protoItem );

	if( typeStr == "none" )
		return false;

	::string 	name    = "",
				picMap  = "",
				picInv  = "",
				oldName = "",
				outName = "";
	::GetNameByHash( protoItem.PicMap , picMap );
	::GetNameByHash( protoItem.PicInv , picInv );
	
	::array<::string@> words = ::splitEx( picMap, "\\" );
	name = words[words.length() - 1];
	
	if(::CheckFile( DirectoryResource + "" + picMap, outName ))
	{
		@words[words.length() - 1] = outName;
		picMap = ::join ( words, "/");
		
		words = ::splitEx( picInv, "\\" );
		oldName = words[words.length() - 1];
		
		outName = "";
		if(::CheckFile( DirectoryResource + "" + picInv, outName ))
		{
			@words[words.length() - 1] = outName;
			picInv = ::join ( words, "/");
		}
		// strlwr
		if( oldName.length() <= 3 || ::strlwr(oldName) == "reserved.frm" )
			oldName = name;
		name = "";
		if( ::IsMsgStr( TEXTMSG_ITEM, protoItem.ProtoId*100 ) )
		{
			//::Message( )
			name = ::GetMsgStr(TEXTMSG_ITEM, protoItem.ProtoId*100);
			if( name.length() > 3 )
			{
				name = ConvertWord( name );
			}
		}
		if( name.length() <= 3 || IsContentName( name ) )
		{
			name = ConvertWord( ::substring( oldName, 0, ::findFirst( oldName, "." ) ) );
			oldName = name;
			uint index = 0;
			while( IsContentName( name ) )
			{
				name = oldName + "" + (++index);
			}
		}
		
		::CreateFolder( DirectoryOutItems + "" + typeStr );
		
		::file fileProtoItem;
		if( fileProtoItem.open ( DirectoryOutItems + typeStr + "/" + name + ".foitem", "r") != 0 )
		{
			if( fileProtoItem.open ( DirectoryOutItems +  typeStr + "/" + name + ".foitem", "w") == 0 )
			{
				fileProtoItem.writeString( "[ProtoItem]\n" );
	
				fileProtoItem.writeString( "PicMap = " + picMap +"\n" );
				fileProtoItem.writeString( "PicInv = " + picInv +"\n" );
				fileProtoItem.writeString( "Type = " + typeStr +"\n" );
	
				
				BoolWriteItemProp( FLAG(protoItem.Flags,ITEM_HIDDEN), "IsHidden", fileProtoItem );
				BoolWriteItemProp( FLAG(protoItem.Flags,ITEM_FLAT), "IsFlat", fileProtoItem );
				BoolWriteItemProp( FLAG(protoItem.Flags,ITEM_NO_BLOCK), "IsNoBlock", fileProtoItem );
				BoolWriteItemProp( FLAG(protoItem.Flags,ITEM_SHOOT_THRU), "IsShootThru", fileProtoItem );
				BoolWriteItemProp( FLAG(protoItem.Flags,ITEM_LIGHT_THRU), "IsLightThru", fileProtoItem );
				BoolWriteItemProp( FLAG(protoItem.Flags,ITEM_ALWAYS_VIEW), "IsAlwaysView", fileProtoItem );
				BoolWriteItemProp( FLAG(protoItem.Flags,ITEM_BAD_ITEM), "IsBadItem", fileProtoItem );
				BoolWriteItemProp( FLAG(protoItem.Flags,ITEM_NO_HIGHLIGHT), "IsNoHighlight", fileProtoItem );
				BoolWriteItemProp( FLAG(protoItem.Flags,ITEM_SHOW_ANIM), "IsShowAnim", fileProtoItem );
				BoolWriteItemProp( FLAG(protoItem.Flags,ITEM_SHOW_ANIM_EXT), "IsShowAnimExt", fileProtoItem );
				BoolWriteItemProp( FLAG(protoItem.Flags,ITEM_LIGHT), "IsLight", fileProtoItem );
				BoolWriteItemProp( FLAG(protoItem.Flags,ITEM_GECK), "IsGeck", fileProtoItem );
				BoolWriteItemProp( FLAG(protoItem.Flags,ITEM_TRAP), "IsTrap", fileProtoItem );
				BoolWriteItemProp( FLAG(protoItem.Flags,ITEM_NO_LIGHT_INFLUENCE), "IsNoLightInfluence", fileProtoItem );
				BoolWriteItemProp( FLAG(protoItem.Flags,ITEM_GAG), "IsGag", fileProtoItem );
				BoolWriteItemProp( FLAG(protoItem.Flags,ITEM_COLORIZE), "IsColorize", fileProtoItem );
				BoolWriteItemProp( FLAG(protoItem.Flags,ITEM_COLORIZE_INV), "IsColorizeInv", fileProtoItem );
				BoolWriteItemProp( FLAG(protoItem.Flags,ITEM_CAN_TALK), "IsCanTalk", fileProtoItem );
				BoolWriteItemProp( FLAG(protoItem.Flags,ITEM_RADIO), "IsRadio", fileProtoItem );
				BoolWriteItemProp( protoItem.DisableEgg, "DisableEgg", fileProtoItem );
				BoolWriteItemProp( protoItem.Stackable, "Stackable", fileProtoItem );
				BoolWriteItemProp( protoItem.GroundLevel, "GroundLevel", fileProtoItem );
				
				
				IntegerWriteItemProp( protoItem.AnimWaitBase, "AnimWaitBase", fileProtoItem );
				IntegerWriteItemProp( protoItem.AnimWaitRndMin, "AnimWaitRndMin", fileProtoItem );
				IntegerWriteItemProp( protoItem.AnimWaitRndMax, "AnimWaitRndMax", fileProtoItem );
				IntegerWriteItemProp( protoItem.AnimStay_0, "AnimStay_0", fileProtoItem );
				IntegerWriteItemProp( protoItem.AnimStay_1, "AnimStay_1", fileProtoItem );
				IntegerWriteItemProp( protoItem.AnimShow_0, "AnimShow_0", fileProtoItem );
				IntegerWriteItemProp( protoItem.AnimShow_1, "AnimShow_1", fileProtoItem );
				IntegerWriteItemProp( protoItem.AnimHide_0, "AnimHide_0", fileProtoItem );
				IntegerWriteItemProp( protoItem.AnimHide_1, "AnimHide_1", fileProtoItem );
				IntegerWriteItemProp( protoItem.SpriteCut, "SpriteCut", fileProtoItem );
				IntegerWriteItemProp( protoItem.DrawOrderOffsetHexY, "DrawOrderOffsetHexY", fileProtoItem );
				IntegerWriteItemProp( protoItem.OffsetX, "OffsetX", fileProtoItem );
				IntegerWriteItemProp( protoItem.OffsetY, "OffsetY", fileProtoItem );
				
				IntegerWriteItemProp( protoItem.Weapon_Anim1, "Weapon_Anim1", fileProtoItem );
				IntegerWriteItemProp( protoItem.RadioChannel, "RadioChannel", fileProtoItem );
				IntegerWriteItemProp( protoItem.RadioFlags, "RadioFlags", fileProtoItem );
				IntegerWriteItemProp( protoItem.RadioBroadcastSend, "RadioBroadcastSend", fileProtoItem );
				IntegerWriteItemProp( protoItem.RadioBroadcastRecv, "RadioBroadcastRecv", fileProtoItem );
				
				IntegerWriteItemProp( protoItem.Armor_CrTypeMale, "Armor_CrTypeMale", fileProtoItem );
				IntegerWriteItemProp( protoItem.Armor_CrTypeFemale, "Armor_CrTypeFemale", fileProtoItem );
				IntegerWriteItemProp( protoItem.Armor_AC, "Armor_AC", fileProtoItem );
				IntegerWriteItemProp( protoItem.Armor_Perk, "Armor_Perk", fileProtoItem );
				IntegerWriteItemProp( protoItem.Armor_DRNormal, "Armor_DRNormal", fileProtoItem );
				IntegerWriteItemProp( protoItem.Armor_DRLaser, "Armor_DRLaser", fileProtoItem );
				IntegerWriteItemProp( protoItem.Armor_DRFire, "Armor_DRFire", fileProtoItem );
				IntegerWriteItemProp( protoItem.Armor_DRPlasma, "Armor_DRPlasma", fileProtoItem );
				IntegerWriteItemProp( protoItem.Armor_DRElectr, "Armor_DRElectr", fileProtoItem );
				IntegerWriteItemProp( protoItem.Armor_DREmp, "Armor_DREmp", fileProtoItem );
				IntegerWriteItemProp( protoItem.Armor_DRExplode, "Armor_DRExplode", fileProtoItem );
				IntegerWriteItemProp( protoItem.Armor_DTNormal, "Armor_DTNormal", fileProtoItem );
				IntegerWriteItemProp( protoItem.Armor_DTLaser, "Armor_DTLaser", fileProtoItem );
				IntegerWriteItemProp( protoItem.Armor_DTFire, "Armor_DTFire", fileProtoItem );
				IntegerWriteItemProp( protoItem.Armor_DTPlasma, "Armor_DTPlasma", fileProtoItem );
				IntegerWriteItemProp( protoItem.Armor_DTElectr, "Armor_DTElectr", fileProtoItem );
				IntegerWriteItemProp( protoItem.Armor_DTEmp, "Armor_DTEmp", fileProtoItem );
				IntegerWriteItemProp( protoItem.Armor_DTExplode, "Armor_DTExplode", fileProtoItem );
				IntegerWriteItemProp( protoItem.Emp_SlowEffect, "Emp_SlowEffect", fileProtoItem );
				IntegerWriteItemProp( protoItem.Emp_TimeSlow, "Emp_TimeSlow", fileProtoItem );
				IntegerWriteItemProp( protoItem.Emp_LostAP, "Emp_LostAP", fileProtoItem );
				IntegerWriteItemProp( protoItem.Weapon_TypeAttack_0, "Weapon_TypeAttack_0", fileProtoItem );
				IntegerWriteItemProp( protoItem.Weapon_TypeAttack_1, "Weapon_TypeAttack_1", fileProtoItem );
				IntegerWriteItemProp( protoItem.Weapon_TypeAttack_2, "Weapon_TypeAttack_2", fileProtoItem );
				
				IntegerWriteItemProp( protoItem.Weapon_DmgType_0, "Weapon_DmgType_0", fileProtoItem );
				IntegerWriteItemProp( protoItem.Weapon_DmgType_1, "Weapon_DmgType_1", fileProtoItem );
				IntegerWriteItemProp( protoItem.Weapon_DmgType_2, "Weapon_DmgType_2", fileProtoItem );
				
				IntegerWriteItemProp( protoItem.Weapon_Anim2_0, "Weapon_Anim2_0", fileProtoItem );
				IntegerWriteItemProp( protoItem.Weapon_Anim2_1, "Weapon_Anim2_1", fileProtoItem );
				IntegerWriteItemProp( protoItem.Weapon_Anim2_2, "Weapon_Anim2_2", fileProtoItem );
				
				IntegerWriteItemProp( protoItem.Weapon_DmgMin_0, "Weapon_DmgMin_0", fileProtoItem );
				IntegerWriteItemProp( protoItem.Weapon_DmgMin_1, "Weapon_DmgMin_1", fileProtoItem );
				IntegerWriteItemProp( protoItem.Weapon_DmgMin_2, "Weapon_DmgMin_2", fileProtoItem );
				
				IntegerWriteItemProp( protoItem.Weapon_DmgMax_0, "Weapon_DmgMax_0", fileProtoItem );
				IntegerWriteItemProp( protoItem.Weapon_DmgMax_1, "Weapon_DmgMax_1", fileProtoItem );
				IntegerWriteItemProp( protoItem.Weapon_DmgMax_2, "Weapon_DmgMax_2", fileProtoItem );
				
				IntegerWriteItemProp( protoItem.Weapon_Effect_0, "Weapon_Effect_0", fileProtoItem );
				IntegerWriteItemProp( protoItem.Weapon_Effect_1, "Weapon_Effect_1", fileProtoItem );
				IntegerWriteItemProp( protoItem.Weapon_Effect_2, "Weapon_Effect_2", fileProtoItem );
				
				BoolWriteItemProp( protoItem.Weapon_Remove_0 , "Weapon_Remove_0", fileProtoItem );
				BoolWriteItemProp( protoItem.Weapon_Remove_1 , "Weapon_Remove_1", fileProtoItem );
				BoolWriteItemProp( protoItem.Weapon_Remove_2 , "Weapon_Remove_2", fileProtoItem );
				BoolWriteItemProp( protoItem.Weapon_UnarmedArmorPiercing , "Weapon_UnarmedArmorPiercing", fileProtoItem );
				BoolWriteItemProp( protoItem.Weapon_ZoneAttackIgnoreNotRaked , "Weapon_ZoneAttackIgnoreNotRaked", fileProtoItem );
				
				IntegerWriteItemProp( protoItem.Weapon_ReloadAp, "Weapon_ReloadAp", fileProtoItem );
				IntegerWriteItemProp( protoItem.Weapon_UnarmedCriticalBonus, "Weapon_UnarmedCriticalBonus", fileProtoItem );
				IntegerWriteItemProp( protoItem.Weapon_CriticalFailture, "Weapon_CriticalFailture", fileProtoItem );
				IntegerWriteItemProp( protoItem.Weapon_LightningRadius, "Weapon_LightningRadius", fileProtoItem );
				IntegerWriteItemProp( protoItem.Weapon_LightningCountTarget, "Weapon_LightningCountTarget", fileProtoItem );
				IntegerWriteItemProp( protoItem.Weapon_FlyingDistance, "Weapon_FlyingDistance", fileProtoItem );
				IntegerWriteItemProp( protoItem.Weapon_SecondPerk, "Weapon_SecondPerk", fileProtoItem );
				IntegerWriteItemProp( protoItem.Weapon_CriticalBonus, "Weapon_CriticalBonus", fileProtoItem );
				IntegerWriteItemProp( protoItem.Weapon_BonusCritRoll, "Weapon_BonusCritRoll", fileProtoItem );
				IntegerWriteItemProp( protoItem.Weapon_NoBurst_0, "Weapon_NoBurst_0", fileProtoItem );
				IntegerWriteItemProp( protoItem.Weapon_NoBurst_1, "Weapon_NoBurst_1", fileProtoItem );
				IntegerWriteItemProp( protoItem.Weapon_NoBurst_2, "Weapon_NoBurst_2", fileProtoItem );
				IntegerWriteItemProp( protoItem.Weapon_IgnoreAC, "Weapon_IgnoreAC", fileProtoItem );
				IntegerWriteItemProp( protoItem.Weapon_BonusToHit, "Weapon_BonusToHit", fileProtoItem );
				IntegerWriteItemProp( protoItem.HexWeapon_Radius, "HexWeapon_Radius", fileProtoItem );
				IntegerWriteItemProp( protoItem.BonusForOutOfCombat, "BonusForOutOfCombat", fileProtoItem );
				IntegerWriteItemProp( protoItem.CraftInfo, "CraftInfo", fileProtoItem );
				IntegerWriteItemProp( protoItem.MaxRepairCount, "MaxRepairCount", fileProtoItem );
				IntegerWriteItemProp( protoItem.Randomisable, "Randomisable", fileProtoItem );
				IntegerWriteItemProp( protoItem.IndexCraftList, "IndexCraftList", fileProtoItem );
				IntegerWriteItemProp( protoItem.IsReadableBook, "IsReadableBook", fileProtoItem );
				IntegerWriteItemProp( protoItem.BookAddPoint, "BookAddPoint", fileProtoItem );
				IntegerWriteItemProp( protoItem.BookCountRead, "BookCountRead", fileProtoItem );
				IntegerWriteItemProp( protoItem.IsSkillBook, "IsSkillBook", fileProtoItem );
				IntegerWriteItemProp( protoItem.BookNumberParam, "BookNumberParam", fileProtoItem );
				IntegerWriteItemProp( protoItem.BookNumber, "BookNumber", fileProtoItem );
				IntegerWriteItemProp( protoItem.BrokenCoefficient, "BrokenCoefficient", fileProtoItem );
				
				IntegerWriteItemProp( protoItem.Ammo_AcMod, "Ammo_AcMod", fileProtoItem );
				IntegerWriteItemProp( protoItem.Ammo_DrMod, "Ammo_DrMod", fileProtoItem );
				IntegerWriteItemProp( protoItem.Ammo_DmgMult, "Ammo_DmgMult", fileProtoItem );
				IntegerWriteItemProp( protoItem.Ammo_DmgDiv, "Ammo_DmgDiv", fileProtoItem );
				IntegerWriteItemProp( protoItem.Ammo_Perk, "Ammo_Perk", fileProtoItem );
				IntegerWriteItemProp( protoItem.Ammo_DmgType, "Ammo_DmgType", fileProtoItem );
				IntegerWriteItemProp( protoItem.Ammo_DTDiv, "Ammo_DTDiv", fileProtoItem );
				
				IntegerWriteItemProp( protoItem.Upgrade_Trigger, "Upgrade_Trigger", fileProtoItem );
				IntegerWriteItemProp( protoItem.Upgrade_TriggerValue0, "Upgrade_TriggerValue0", fileProtoItem );
				IntegerWriteItemProp( protoItem.Upgrade_TriggerValue1, "Upgrade_TriggerValue1", fileProtoItem );
				IntegerWriteItemProp( protoItem.Upgrade_Effect, "Upgrade_Effect", fileProtoItem );
				IntegerWriteItemProp( protoItem.Upgrade_EffectValue0, "Upgrade_EffectValue0", fileProtoItem );
				IntegerWriteItemProp( protoItem.Upgrade_EffectValue1, "Upgrade_EffectValue1", fileProtoItem );
				IntegerWriteItemProp( protoItem.Upgrade_Type, "Upgrade_Type", fileProtoItem );
				IntegerWriteItemProp( protoItem.Upgrade_TypeValue0, "Upgrade_TypeValue0", fileProtoItem );
				IntegerWriteItemProp( protoItem.Upgrade_TypeValue1, "Upgrade_TypeValue1", fileProtoItem );
								
				fileProtoItem.writeString( "\n" );
				
				::string str = "{"+protoItem.ProtoId*100+"}{}{";
				uint lenStr = str.length();
				int index = ::findFirst ( __MSGObjectRuss, str);
				if( index > 0 )
				{					
					fileProtoItem.writeString( "[Text_russ]\n{1}{}{" + ::substring( __MSGObjectRuss, index + lenStr, ::findFirst ( __MSGObjectRuss, "}", index + lenStr ) - ( index + lenStr ) ) + "}\n" );
					index = ::findFirst ( __MSGObjectRuss, "{"+(protoItem.ProtoId*100+1)+"}{}{", index + lenStr );
					if( index > 0 )
						fileProtoItem.writeString( "{2}{}{" + ::substring( __MSGObjectRuss, index + lenStr, ::findFirst ( __MSGObjectRuss, "}", index + lenStr ) - ( index + lenStr ) ) + "}\n" );
				}
				
				fileProtoItem.writeString( "\n" );
				index = ::findFirst ( __MSGObjectEngl, str);
				if( index > 0 )
				{					
					fileProtoItem.writeString( "[Text_engl]\n{1}{}{" + ::substring( __MSGObjectEngl, index + lenStr, ::findFirst ( __MSGObjectEngl, "}", index + lenStr ) - ( index + lenStr ) ) + "}\n" );
					index = ::findFirst ( __MSGObjectEngl, "{"+(protoItem.ProtoId*100+1)+"}{}{", index + lenStr );
					if( index > 0 )
						fileProtoItem.writeString( "{2}{}{" + ::substring( __MSGObjectEngl, index + lenStr, ::findFirst ( __MSGObjectEngl, "}", index + lenStr ) - ( index + lenStr ) ) + "}\n" );
				}
								
				fileProtoItem.close();
				@ retCtx = Context ( name, ( ( protoItem.Type >= ITEM_TYPE_GRID || protoItem.Type <= ITEM_TYPE_WALL ) ? ( Convert::ContextType::ContextScenery ) : ( Convert::ContextType::ContextItem ) ) );
				return true;
			}
			else ::Message( "No open content script." );
		}
		else 
		{
			fileProtoItem.close();
			@ retCtx = Context ( name, ( ( protoItem.Type >= ITEM_TYPE_GRID || protoItem.Type <= ITEM_TYPE_WALL ) ? ( Convert::ContextType::ContextScenery ) : ( Convert::ContextType::ContextItem ) ) );
			return false;
		}
	}
	return false;
}

void LineParse( ::string&in line, Context&inout map )
{
	if( line == "[Header]")
	{	
		map.CurrentSection += "[ProtoMap]\n";
	}
	else
	{
		::array<::string@> allWord = ::splitEx( line, " " );
		if( allWord.length() > 0 )
		{
			if( allWord[0] == "MaxHexX")
			{
				int value = 0;
				::StrToInt( allWord[1],value );
				if( value < 200 )
					value = 200;
					
				map.X = value;
				map.TilesCount.resize(map.X);
				for( uint x = 0; x < map.X; x++ )
				{
					map.TilesCount[x].resize(map.Y);
					for( uint y = 0; y < map.Y; y++ )
						map.TilesCount[x][y] = 0;
				}
				map.CurrentSection += ("Width = " + map.X + "\n");
			}
			else if( allWord[0] == "MaxHexY")
			{
				int value = 0;
				::StrToInt( allWord[1],value );
				if( value < 200 )
					value = 200;
				
				map.Y = value;
				map.TilesCount.resize(map.X);
				for( uint x = 0; x < map.X; x++ )
				{
					map.TilesCount[x].resize(map.Y);
					for( uint y = 0; y < map.Y; y++ )
						map.TilesCount[x][y] = 0;
				}
				map.CurrentSection += ("Height = " + map.Y + "\n");
			}
			else if( allWord[0] == "WorkHexX")
			{
				map.CurrentSection += ("WorkHexX = " + allWord[1] + "\n");
			}
			else if( allWord[0] == "WorkHexY")
			{
				map.CurrentSection += ("WorkHexY = " + allWord[1] + "\n");
			}
			else if( allWord[0] == "DayTime")
			{
				map.CurrentSection += ("DayTime = " + allWord[1] + " " + allWord[2] + " " + allWord[3] + " " + allWord[4] +"\n");
			}
			else if( allWord[0] == "tile" || allWord[0] == "roof")
			{
				bool isAdd = true;
				
				if( allWord[0] == "tile" )
				{
					int x = 0, y = 0;
					::StrToInt( allWord[1], x );
					::StrToInt( allWord[2], y );
					isAdd = map.TilesCount[x][y]++ == 0;
				}
				if( isAdd )
				{
					map.CurrentSection += ("\n[Tile]" + "\nHexX = " + allWord[1] + "\nHexY = " + allWord[2] + "" + 
					(( allWord[0] != "roof" )?( "\nLayer = 1\nPicMap = " ) : ( "\nIsRoof = true\nPicMap = " ))
					+ allWord[3] +"\n");
				}				
			}
			else if( allWord[0] == "MapObjType" )
			{
				int value = Convert::ContextType::ContextNone;
				::StrToInt( allWord[1],value );
				map.refreshObject( value );
			}
			else if( allWord[0] == "ProtoId" )
			{
				if( map.CurrentObjectType == Convert::ContextType::ContextCritter )
					@allWord[1] = "Critter_" + allWord[1];
				
				::ProtoItem@ protoItem = null;
				Context@ obj = null;
				if(IsContent( allWord[1] ))
				{
					@obj = Content[ allWord[1] ];
					@map.CurrentObject = obj;
				}
				else
				{
					
					switch( map.CurrentObjectType )
					{
					case Convert::ContextType::ContextItem:
					case Convert::ContextType::ContextScenery:
						{
							int pid = 0;
							::StrToInt( allWord[1],pid );
							@ protoItem = ::GetProtoItem( pid );
							
							if( @protoItem !is null )
							{
								if( ConvertProtoItem( protoItem, obj ) )
									map.ContentFile.writeString( "#pragma content Item " + obj.Name + "\n" );
								
								if( @obj !is null )
								{
									@ obj.ContentFile = map.ContentFile; 
									@ Content[ "" + pid ] = obj;
									@ map.CurrentObject = obj;
								}
							}
						} break;
							
					default: @map.CurrentObject = null; 
						break;
					}
				}
				
				if( !map.validCurrentObject )
				{
					@obj = Content[ allWord[1] ];
					@map.CurrentObject = obj;
				}
				
			}
			else if( allWord[0] == "Dir" )
			{
				if( map.validCurrentObject )
				{
					map.CurrentObject.CurrentSection+=("Dir = " + allWord[1] + "\n");
				}
			}
			else if( allWord[0] == "MapX" )
			{
				if( map.validCurrentObject )
				{
					
					int value = 0;
					::StrToInt( allWord[1],value );						
					map.CurrentObject.X = value;
				}
			}
			else if( allWord[0] == "MapY" )
			{
				if( map.validCurrentObject )
				{
					int value = 0;
					::StrToInt( allWord[1],value );						
					map.CurrentObject.Y = value;
				}
			}
			else if( allWord[0] == "UID" )
			{
				if( map.validCurrentObject )
				{
					map.UIDMemmory.set( allWord[1], map.CurrentObject );
				}
			}
			else if( allWord[0] == "ContainerUID" )
			{
				if( map.validCurrentObject )
				{
					int value = 0;
					::StrToInt( allWord[1],value );						
					map.CurrentObject.ContainerUID = value;
				}
			}
			else if( allWord[0] == "Scenery_ToMapPid" )
			{
				if( map.validCurrentObject )
				{
					@allWord[1] = "MapPid_" + allWord[1];
					if(IsContent( allWord[1] ))
					{
						Context@ obj = Content[ allWord[1] ];
						if( @obj !is null )
						{
							map.CurrentObject.CurrentSection+=("Grid_ToMap = " + ( obj.Name ) + "\n");
						}
					}
				
				}
			}			
			else if( allWord[0] == "LightDistance" )
			{
				if( map.validCurrentObject )
				{
					map.CurrentObject.CurrentSection+=("LightDistance = " + allWord[1] + "\n");
				}
			}
			else if( allWord[0] == "Item_Count" )
			{
				if( map.validCurrentObject )
				{
					map.CurrentObject.CurrentSection+=("Count = " + allWord[1] + "\n");
				}
			}
			else if( allWord[0] == "LightColor" )
			{
				if( map.validCurrentObject )
				{
					map.CurrentObject.CurrentSection+=("LightColor = " + allWord[1] + "\n");
				}
			}
			else if( allWord[0] == "LightIntensity" )
			{
				if( map.validCurrentObject )
				{
					map.CurrentObject.CurrentSection+=("LightIntensity = " + allWord[1] + "\n");
				}
			}
			else if( allWord[0] == "LightFlags" )
			{
				if( map.validCurrentObject )
				{
					map.CurrentObject.CurrentSection+=("LightFlags = " + allWord[1] + "\n");
				}
			}
			else if( allWord[0] == "Scenery_ToEntire" )
			{
				if( map.validCurrentObject )
				{
					map.CurrentObject.CurrentSection+=("Grid_ToMapEntire = " + allWord[1] + "\n");
					int value = 0;
					::StrToInt( allWord[1], value );
					if( value < 0 || value > 100 )
					{
						@map.CurrentObject = null; 
					}
				}
			}
			else if( allWord[0] == "Scenery_ToDir" )
			{
				if( map.validCurrentObject )
				{
					map.CurrentObject.CurrentSection+=("Grid_ToMapDir = " + allWord[1] + "\n");
				}
			}
			else if( allWord[0] == "PicMapName" )
			{
				if( map.validCurrentObject )
				{
					map.CurrentObject.CurrentSection+=("PicMap = " + allWord[1] + "\n");
				}
			}
			if( allWord[0] == "PicInvName" )
			{
				if( map.validCurrentObject )
				{
					map.CurrentObject.CurrentSection+=("PicInv = " + allWord[1] + "\n");
				}
			}
			else if( ::substring( allWord[ 0 ], 0, allWord[ 0 ].length() - 1 ) == "DayColor")
			{
				Color col(allWord[ 1 ],allWord[ 2 ],allWord[ 3 ]);
				map.DayColors.insertLast( @col );
				if( map.DayColors.length() == 4 )
				{
					map.CurrentSection+=( "DayColor = " + map.DayColors[0].R + " " + map.DayColors[1].R + " " + map.DayColors[2].R + " " + map.DayColors[3].R + 
													" " + map.DayColors[0].G + " " + map.DayColors[1].G + " " + map.DayColors[2].G + " " + map.DayColors[3].G + 
													" " + map.DayColors[0].B + " " + map.DayColors[1].B + " " + map.DayColors[2].B + " " + map.DayColors[3].B + 
													"\n" );
				}
			}
		}
	}
}

::string _Map( ::string@ nameMap )
{
	::file inFile, outFile, contentFile, mapListingFile;
	
	if( contentFile.open ( DirectoryOutItems + ContentFileItems, "r") != 0 )
	{
		if( contentFile.open ( DirectoryOutItems + ContentFileItems, "w") != 0 )
			return "No open content script.";
			
		contentFile.writeString( "//FOS Common Sort -1\n" );
		
	}
	
	contentFile.close();
	
	if( contentFile.open ( DirectoryOutItems + ContentFileItems, "a") != 0 )
		return "No open content script.";
	
	if( inFile.open ( DirectoryOldMaps + nameMap + ".fomap", "r") == 0 )
	{
		{
			//name = words[words.length() - 1];
			nameMap = ::substring( nameMap, 0, ::findFirst( nameMap, "." ) );
			::array<::string@> words = ::splitEx( nameMap, "_" );
			nameMap = "";
			::string letter = " ";
			for( uint i = 0, iEnd = words.length(); i < iEnd; i++ )
			{
				letter[0] = words[i][0];
				letter = ::strupr( letter );
				words[i][0] = letter[0];
				nameMap = nameMap + words[i];
			}
		}
	
		if( outFile.open ( DirectoryOutMaps + nameMap + ".fomap", "r") != 0 )
		{			
			if( mapListingFile.open ( DirectoryOutMaps + ContentFileMaps, "r") != 0 )
			{
				if( mapListingFile.open ( DirectoryOutMaps + ContentFileMaps, "w") != 0 )
				{
					contentFile.close();
					return "No open content script.";
				}
				
				mapListingFile.writeString( "//FOS Common Sort -1\n" );
			}
			else mapListingFile.open ( DirectoryOutMaps + ContentFileMaps, "a");
			
			{				
				mapListingFile.writeString( "#pragma content Map " + nameMap + "\n" );
				mapListingFile.close();
			}
		}
		else outFile.close();
		
		
		::string@ str = "";
		inFile.readString( uint( inFile.getSize( ) ), str );
		inFile.close();
			
		InitializeContent( );
		
		::array<::string@> allLines = ::splitEx( str, "\n" );
		@ str = null;
		Context map( nameMap, Convert::ContextType::ContextMapFile, contentFile );	
		
		
		if( __CashFile.open( CashFileName, "a") == 0 )
		{				
			for( uint i = 0, iEnd = allLines.length(); i < iEnd; i++ )
			{
				if( @allLines[i] !is null)
					LineParse(allLines[i], map );
			}
			if( outFile.open ( DirectoryOutMaps + nameMap + ".fomap", "w") == 0 )
			{
				map.refreshObject( Convert::ContextType::ContextNone );
				map.WriteSection( outFile, map );
				outFile.close();
			}
			__CashFile.close( );
		}
	}
	
	contentFile.close();
	return "Done";
}

// Commands:
::string Map( ::string nameMap )
{
	return _Map( @nameMap );
}

::string CrType( ::string count )
{
	int value = 0;
	::StrToInt( count, value);
	for( int i = 0; i < value; i++)
	{
		::string@ name = ::GetCritterTypeName(uint(i));
		if( @name !is null && name.length() > 2 )
			Log( "" + i + " - " + name );
	}
	return "Done";
}

::string IsFile(::string str)
{
	::string outStr = "";
	::CheckFile( str, outStr );
	return "File " + outStr;
}

uint IndexAllMaps = 0;

::string AllMaps(::string str)
{
	IndexAllMaps = 0;
	::GetMyFolderFiles( str, str );
	::array<::string@> allLines = ::splitEx( str, "\n" );
	for( uint i = IndexAllMaps, iEnd = allLines.length(); IndexAllMaps < iEnd; IndexAllMaps++ )
	{
		::Message( _Map( ::substring( allLines[IndexAllMaps], 0, ::findFirst( allLines[IndexAllMaps], "." ) ) ) );
		if( IndexAllMaps - i == 50 )
			return "Break";
	}
	return "CountMaps " + allLines.length();
}

::string SetMapsListingPosition( ::string count )
{
	int value = 0;
	::StrToInt( count, value);
	IndexAllMaps = value;
	return "Done";
}

//#Mk2@Convert::FormatCritterParams Params.content
::string FormatCritterParams( ::string fileName )
{
	::file outFile;
	::file inFile;
	
	if( inFile.open( "D:\\FalloutOnline\\Server\\data\\ParamNames.lst", "r") == 0 )
	{
		::string str = "";
		inFile.readString( uint( inFile.getSize( ) ), str );
		inFile.close();
		
		if( outFile.open( fileName, "w" ) == 0 )
		{
			::array<::string@> allLines = ::splitEx( str, "\n" );
			::array<::string@> words;
			str = "";

			int startIndex = 0, currentIndex = 0;
			
			for( uint i = 0, iEnd = allLines.length(); i < iEnd; i++ )
			{
				if( @allLines[i] !is null)
				{
					words = ::splitEx( allLines[i], " " );
					if( words.length() == 2 )
					{
						::StrToInt( words[0], currentIndex );
						outFile.writeString( "Param_" + ( startIndex + currentIndex ) + " " + ConvertWord( ::strlwr( ::substring( words[1], ::findFirst( words[1], "_" ) + 1, words[1].length() ) ) ) );// + " " + Convert::ContextType::ContextCritterParam + "\n" , null, ConvertWord( ::strlwr( ::substring( words[1], 0, ::findFirst( words[1], "_" ) ) ) ) );
					}
					else if( words.length() == 1 && words[0].length() > 1 )
					{
						if( words[0][0] == '*' )
						{
							::StrToInt( ::substring( words[0], 1, words[0].length() - 1 ), startIndex );
						}
					}
				}
			}
			outFile.close();
		}
	}
	return "Done";
}

::string ResumeAllMaps(::string str)
{
	::string outName = "";
	::GetMyFolderFiles( str, outName );
	::array<::string@> allLines = ::splitEx( outName, "\n" );
	for( uint i = IndexAllMaps, iEnd = allLines.length(); IndexAllMaps < iEnd; IndexAllMaps++ )
	{
		::Message( _Map( ::substring( allLines[IndexAllMaps], 0, ::findFirst( allLines[IndexAllMaps], "." ) ) ) );
		if( IndexAllMaps - i == 50 )
			return "Break";
	}
	return "CountMaps " + allLines.length();
}
