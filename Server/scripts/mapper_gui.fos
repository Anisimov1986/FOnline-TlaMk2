// Autor: Cracker
// mapper gui

#define SIZE_KEYBOARD           ( 0x100 )
#define TIME_NO_CLOSE_SCREEN    ( 50 )  // ms

#define _MAPPER_GUI

#include "mapper_gui_h.fos"

CKeyboard@ Keyboard;
GUIScreen@[] AllScreens;
GUIScreen@[] DynamicScreens;

GUIScreen@[] ActivScreens;

bool __ConsoleActive = false;
uint ActivWarningScreen = 0;
ICallbackMouseMove@[] MouseMoveEvents;
IEventClickMouse@[] MouseClickEvents;
IEventDraw@[] DrawEvents;
IEventDrawMap@[] DrawMapEvents;
ICallbackKey@[] PressKeyEvents;

class CKeyboard
{
    CKeyboard()
    {
        file fh;
        if( fh.open( "hotkey.help", "w" ) != -1 )
        {
            fh.close();
        }
        Keys.resize( SIZE_KEYBOARD );
        for( uint i = 0; i < SIZE_KEYBOARD; i++ )
            @Keys[ i ] = CKey( 0, 0, 0, 0 );
        @Keys[ DIK_1 ] = CKey( '1', '!', '1', '!' );
        @Keys[ DIK_2 ] = CKey( '2', '"', '2', '@' ); // "
        @Keys[ DIK_3 ] = CKey( '3', '№', '3', '#' );
        @Keys[ DIK_4 ] = CKey( '4', ';', '4', '$' );
        @Keys[ DIK_5 ] = CKey( '5', '%', '5', '%' );
        @Keys[ DIK_6 ] = CKey( '6', ':', '6', '^' );
        @Keys[ DIK_7 ] = CKey( '7', '?', '7', '&' );
        @Keys[ DIK_8 ] = CKey( '8', '*', '8', '*' );
        @Keys[ DIK_9 ] = CKey( '9', '(', '9', '(' );
        @Keys[ DIK_0 ] = CKey( '0', ')', '0', ')' );
        @Keys[ DIK_MINUS ] = CKey( '-', '_', '-', '_' );
        @Keys[ DIK_EQUALS ] = CKey( '=', '+', '=', '+' );
        @Keys[ DIK_Q ] = CKey( 'й', 'Й', 'q', 'Q' );
        @Keys[ DIK_W ] = CKey( 'ц', 'Ц', 'w', 'W' );
        @Keys[ DIK_E ] = CKey( 'у', 'У', 'e', 'E' );
        @Keys[ DIK_R ] = CKey( 'к', 'К', 'r', 'R' );
        @Keys[ DIK_T ] = CKey( 'е', 'Е', 't', 'T' );
        @Keys[ DIK_Y ] = CKey( 'н', 'Н', 'y', 'Y' );
        @Keys[ DIK_U ] = CKey( 'г', 'Г', 'u', 'U' );
        @Keys[ DIK_I ] = CKey( 'ш', 'Ш', 'i', 'I' );
        @Keys[ DIK_O ] = CKey( 'щ', 'Щ', 'o', 'O' );
        @Keys[ DIK_P ] = CKey( 'з', 'З', 'p', 'P' );
        @Keys[ DIK_LBRACKET ] = CKey( 'х', 'Х', '[', '{' );
        @Keys[ DIK_RBRACKET ] = CKey( 'ъ', 'Ъ', ']', '}' );
        @Keys[ DIK_A ] = CKey( 'ф', 'Ф', 'a', 'A' );
        @Keys[ DIK_S ] = CKey( 'ы', 'Ы', 's', 'S' );
        @Keys[ DIK_D ] = CKey( 'в', 'В', 'd', 'D' );
        @Keys[ DIK_F ] = CKey( 'а', 'А', 'f', 'F' );
        @Keys[ DIK_G ] = CKey( 'п', 'П', 'g', 'G' );
        @Keys[ DIK_H ] = CKey( 'р', 'Р', 'h', 'H' );
        @Keys[ DIK_J ] = CKey( 'о', 'О', 'j', 'J' );
        @Keys[ DIK_K ] = CKey( 'л', 'Л', 'k', 'K' );
        @Keys[ DIK_L ] = CKey( 'д', 'Д', 'l', 'L' );
        @Keys[ DIK_SEMICOLON ] = CKey( 'ж', 'Ж', ';', ':' );
        @Keys[ DIK_APOSTROPHE ] = CKey( 'э', 'Э', 39, 39 );
        @Keys[ DIK_Z ] = CKey( 'я', 'Я', 'z', 'Z' );
        @Keys[ DIK_X ] = CKey( 'ч', 'Ч', 'x', 'X' );
        @Keys[ DIK_C ] = CKey( 'с', 'С', 'c', 'C' );
        @Keys[ DIK_V ] = CKey( 'м', 'М', 'v', 'V' );
        @Keys[ DIK_B ] = CKey( 'и', 'И', 'b', 'B' );
        @Keys[ DIK_N ] = CKey( 'т', 'Т', 'n', 'N' );
        @Keys[ DIK_M ] = CKey( 'ь', 'Ь', 'm', 'M' );
        @Keys[ DIK_COMMA ] = CKey( 'б', 'Б', ',', '<' );
        @Keys[ DIK_PERIOD ] = CKey( 'ю', 'Ю', '.', '>' );
        @Keys[ DIK_SLASH ] = CKey( '.', ',', '/', '?' );
        @Keys[ DIK_MULTIPLY ] = CKey( '*', '*', '*', '*' );
        @Keys[ DIK_SPACE ] = CKey( ' ', ' ', ' ', ' ' );
        @Keys[ DIK_GRAVE ] = CKey( 'ё', 'Ё', '`', '~' );
        @Keys[ DIK_NUMPAD1 ] = CKey( '1', '1', '1', '1' );
        @Keys[ DIK_NUMPAD2 ] = CKey( '2', '2', '2', '2' );
        @Keys[ DIK_NUMPAD3 ] = CKey( '3', '3', '3', '3' );
        @Keys[ DIK_NUMPAD4 ] = CKey( '4', '4', '4', '4' );
        @Keys[ DIK_NUMPAD5 ] = CKey( '5', '5', '5', '5' );
        @Keys[ DIK_NUMPAD6 ] = CKey( '6', '6', '6', '6' );
        @Keys[ DIK_NUMPAD7 ] = CKey( '7', '7', '7', '7' );
        @Keys[ DIK_NUMPAD8 ] = CKey( '8', '8', '8', '8' );
        @Keys[ DIK_NUMPAD9 ] = CKey( '9', '9', '9', '9' );
        @Keys[ DIK_NUMPAD0 ] = CKey( '0', '0', '0', '0' );
        @Keys[ DIK_SUBTRACT ] = CKey( '-', '-', '-', '-' );
        @Keys[ DIK_ADD ] = CKey( '+', '+', '+', '+' );
        @Keys[ DIK_DECIMAL ] = CKey( '.', '.', '.', '.' );
        @Keys[ DIK_DIVIDE ] = CKey( '/', '/', '/', '/' );
        @Keys[ DIK_RETURN ] = CKey( '\n', '\n', '\n', '\n' );
        @Keys[ DIK_NUMPADENTER ] = CKey( '\n', '\n', '\n', '\n' );
        @Keys[ DIK_TAB ] = CKey( '\t', '\t', '\t', '\t' );
    }

    bool KeyDown( uint8 key )
    {
        if( valid( Keys[ key ] ) )
        {
            if( DIK_RETURN == key || key == DIK_NUMPADENTER )
                __ConsoleActive = !__ConsoleActive;
            if( !__ConsoleActive )
            {
                for( uint i = 0, iEnd = PressKeyEvents.length(); i < iEnd; i++ )
                    if( PressKeyEvents[ i ].PressKey( key, true ) )
                        return true;
            }
            uint8 result = Keys[ key ].Down();
            if( result > 0 )
                return ( result == 1 );
            if( ActivScreens.length() > 0 )
            {
                if( key == DIK_ESCAPE && ActivScreens[ ActivScreens.length() - 1 ].IsEscClose )
                {
                    GUI_HideScreen( ActivScreens[ ActivScreens.length() - 1 ].Index );
                    return true;
                }
                return ActivScreens[ ActivScreens.length() - 1 ].KeyPress( key, true );
            }
        }
        else
        {
            Message( " Клавиша не валидна. Код клавиши " + key + ". Всего клавиш " + Keys.length() );
            Log( " Клавиша не валидна. Код клавиши " + key + ". Всего клавиш " + Keys.length() );
        }
        return false;
    }

    bool KeyUp( uint8 key )
    {
        if( valid( Keys[ key ] ) )
        {
            uint8 result = Keys[ key ].Up();
            if( result > 0 )
                return ( result == 1 );
            for( uint i = 0, iEnd = PressKeyEvents.length(); i < iEnd; i++ )
                if( PressKeyEvents[ i ].PressKey( key, false ) )
                    return true;
            if( ActivScreens.length() > 0 )
                return ActivScreens[ ActivScreens.length() - 1 ].KeyPress( key, false );
        }
        return false;
    }

    bool IsKeyPress( uint8 key )
    {
        return Keys[ key ].IsPress();
    }

    bool Text( uint8 key, string& text )
    {
        if( key == DIK_BACK )
        {
            if( text.length() > 0 )
                text.resize( text.length() - 1 );
            return true;
        }

        CKey@ k = Keys[ key ];
        if( not (k is null) )
        {
            bool IsShiftDown = false;
            if( not ( Keys[ DIK_LSHIFT ] is null ) )
                IsShiftDown = Keys[ DIK_LSHIFT ].IsPress();
            if( not ( Keys[ DIK_RSHIFT ] is null ) )
                IsShiftDown = Keys[ DIK_RSHIFT ].IsPress() ? true : IsShiftDown;
            uint len = text.length();
            text.resize( len + 1 );
            text[ len ] = k.key[ ::GetKeybLang() * 2 + ( IsShiftDown ? 1 : 0 ) ];
            return true;
        }
        return false;
    }

    bool AddHotKey( ICallbacHotKey@ c, string@ txt, uint8 key, int IsKey = -1 )
    {
        if( key < Keys.length() && valid( Keys[ key ] ) )
        {
            if( valid( txt ) )
            {
                file fh;
                if( fh.open( "hotkey.help", "a" ) != -1 )
                {
                    string t;
                    Text( key, t );
                    if( IsKey != -1 )
                    {
                        if( IsKey == DIK_LSHIFT )
                            t = t + "+" + "LShift";
                        else if( IsKey == DIK_RSHIFT )
                            t = t + "+" + "RShift";
                        else if( IsKey == DIK_LCONTROL )
                            t = t + "+" + "LCtrl";
                        else if( IsKey == DIK_RCONTROL )
                            t = t + "+" + "RCtrl";
                        else
                        {
                            t = t + "+";
                            Text( uint8( IsKey ), t );
                        }
                    }
                    fh.writeString( t + " " + txt + "\n" );
                    fh.close();
                }
            }
            HotKey@ newHot = null;
            if( IsKey > -1 && uint( IsKey ) < ( Keys.length() ) && valid( Keys[ IsKey ] ) )
            {
                @newHot = HotKey( false, c );
                Keys[ IsKey ].IsHKey.insertLast( newHot );
            }

            if( !valid( newHot ) )
                @newHot = HotKey( true, c );
            Keys[ key ].HKey.insertLast( newHot );
            return true;
        }
        Message( "Клавиша отсутствует." );
        Log( "Клавиша отсутствует." );
        return false;
    }

    CKey@[] Keys;
}

class HotKey
{
    HotKey( bool isTrue, ICallbacHotKey@ c )
    {
        IsDown = isTrue;
        @Proccess = c;
    }

    bool            IsDown;
    ICallbacHotKey@ Proccess;
}

class CKey
{
    CKey( int8 Russ, int8 RussShift, int8 Engl, int8 EnglShift )
    {
        key.resize( 4 );
        key[ 0 ] = Russ;
        key[ 1 ] = RussShift;
        key[ 2 ] = Engl;
        key[ 3 ] = EnglShift;

        Press = false;
    }

    uint8 Down()
    {
        Press = true;
        if( __ConsoleActive )
            return 0;
        for( uint i = 0, iEnd = IsHKey.length(); i < iEnd; i++ )
            if( valid( IsHKey[ i ] ) )
                IsHKey[ i ].IsDown = true;
        uint8 result = 0;
        for( uint i = 0, iEnd = HKey.length(); i < iEnd; i++ )
            if( valid( HKey[ i ] ) && HKey[ i ].IsDown  && valid( HKey[ i ].Proccess ) )
            {
                result = HKey[ i ].Proccess.HotKey( true );
                if( result > 0 )
                    return result;
            }
        return 0;
    }

    uint8 Up()
    {
        Press = false;
        if( __ConsoleActive )
            return 0;
        for( uint i = 0, iEnd = IsHKey.length(); i < iEnd; i++ )
            if( valid( IsHKey[ i ] ) )
                IsHKey[ i ].IsDown = false;
        uint8 result = 0;
        for( uint i = 0, iEnd = HKey.length(); i < iEnd; i++ )
            if( valid( HKey[ i ] ) && HKey[ i ].IsDown && valid( HKey[ i ].Proccess ) )
            {
                result = HKey[ i ].Proccess.HotKey( false );
                if( result > 0 )
                    return result;
            }
        return 0;
    }

    bool IsPress()
    {
        return Press;
    }

    private bool Press;
    HotKey@[] IsHKey;
    HotKey@[] HKey;
    uint8[] key;
}

GUIScreen@ GetMainActivScreen()
{
    if( ActivScreens.length() > 0 )
        return ActivScreens[ ActivScreens.length() - 1 ];
    return null;
}

GUIScreen@[] GetActivScreens()
{
    return ActivScreens;
}

class GUIElement : IGUIElement
{
    GUIElement( string@ ImageName, int path, uint index, uint scrollIndex, ScrollElementFlags f = SEF_NO_SCROLL )
    {
        PosX = 0;      // __ScreenWidth/2;
        PosY = 0;      // __ScreenHeight/2;
        if( ImageName.length() > 0 )
        {
            Sprite spr;
            spr.Load( ImageName, path );
            @Image = spr;
        }
        else
            @Image = null;
        IsFirstTime = true;
        IsBlock = false;
        NoMove = false;
        IsLeftMouseDown = false;
        IndexScreen = index;

        @DownSpr = null;
        @CallMouseClick = null;
        @CallDraw = null;
        @CallPosDraw = null;

        ScrollIndex = scrollIndex;
        ScrollFlags = f;
        ScrollOffValue = 0;
        IsRollOver = false;

        OtherRollOff = true;
        FocusTick = 0;
        IsFocus = false;
    }

    void Render_Element( int MonitorX, int MonitorY )
    {
        if( not IsBlock )
        {
            int endX = MonitorX + PosX;
            int endY = MonitorY + PosY;
            if( not (DownSpr is null) )
            {
                if( IsLeftMouseDown )
                {
                    endX += DownSpr.Width;
                    endY += DownSpr.Height;
                    DownSpr.Draw( MonitorX + PosX, MonitorY + PosY );
                }
                else if( not (Image is null) )
                {
                    endX += Image.Width;
                    endY += Image.Height;
                    Image.Draw( MonitorX + PosX, MonitorY + PosY );
                }
                if( not (Txt is null) )
                    Txt.Draw( MonitorX + PosX, MonitorY + PosY );
            }
            else
            {
                if( not (Image is null) )
                {
                    endX += Image.Width;
                    endY += Image.Height;
                    Image.Draw( MonitorX + PosX, MonitorY + PosY );
                }
                if( not (Txt is null) )
                    Txt.Draw( MonitorX + PosX, MonitorY + PosY );
            }
            if( not (CallDraw is null) )
                CallDraw.IDraw();
            if( not (CallPosDraw is null) )
                CallPosDraw.IDraw( MonitorX + PosX, MonitorY + PosY, endX, endY );
        }
    }

    bool MouseClick( int click, bool downClick )
    {
        if( not IsBlock )
        {
            if( click == MOUSE_CLICK_LEFT )
            {
                if( IsRollOver )
                {
                    if( downClick )
                        IsLeftMouseDown = ( !IsLeftMouseDown );
                }
                else
                    IsLeftMouseDown = downClick;
                if( downClick )
                {
                    switch( ScrollFlags )
                    {
                    case SEF_DIR_X:
                    {
                        GUIScrollElements@ scroll = GetScrollElements();
                        if( valid( scroll ) )
                        {
                            scroll.CurrentOffX += ScrollOffValue;
                            if( scroll.CurrentOffX < scroll.MinOffX )
                                scroll.CurrentOffX = scroll.MinOffX;
                            else if( scroll.CurrentOffX > scroll.MaxOffX )
                                scroll.CurrentOffX = scroll.MaxOffX;
                        }
                    }       break;
                    case SEF_DIR_Y:
                    {
                        GUIScrollElements@ scroll = GetScrollElements();
                        if( valid( scroll ) )
                        {
                            scroll.CurrentOffY += ScrollOffValue;
                            if( scroll.CurrentOffY < scroll.MinOffY )
                                scroll.CurrentOffY = scroll.MinOffY;
                            else if( scroll.CurrentOffY > scroll.MaxOffY )
                                scroll.CurrentOffY = scroll.MaxOffY;
                        }
                    }       break;
                    case SEF_DIR_XY:
                    {
                        GUIScrollElements@ scroll = GetScrollElements();
                        if( valid( scroll ) )
                        {
                            scroll.CurrentOffY += ScrollOffValue;
                            if( scroll.CurrentOffY < scroll.MinOffY )
                                scroll.CurrentOffY = scroll.MinOffY;
                            else if( scroll.CurrentOffY > scroll.MaxOffY )
                                scroll.CurrentOffY = scroll.MaxOffY;
                            scroll.CurrentOffX += ScrollOffValue;
                            if( scroll.CurrentOffX < scroll.MinOffX )
                                scroll.CurrentOffX = scroll.MinOffX;
                            else if( scroll.CurrentOffX > scroll.MaxOffX )
                                scroll.CurrentOffX = scroll.MaxOffX;
                        }
                    }       break;
                    /*case SEF_NONE:
                       {

                       } break;*/
                    default:
                        break;
                    }
                }
            }

            if( not (CallMouseClick is null) )
                return CallMouseClick.IClickMouse( click, downClick );
        }
        return false;
    }

    void MouseMove()
    {
        if( !IsFocus )
        {
            IsFocus = true;
            FocusTick = GetTick();
        }
    }

    void Init()
    {
        if( IsFirstTime )
        {
            IsFirstTime = false;
        }
        else
        {}
    }

    IGUIScreen@ GetScreen()
    {
        if( IndexScreen < AllScreens.length() )
            return AllScreens[ IndexScreen ];
        return null;
    }

    IGUIElement@ Position( int x, int y ) { PosX = x;
                                            PosY = y;
                                            return this; }
    IGUIElement@ CallbackDraw( ICallbackDraw@ c ) { @CallDraw = c;
                                                    return this; }
    IGUIElement@ CallbackDrawPos( ICallbackDrawPos@c ) { @CallPosDraw = c;
                                                         return this; }
    IGUIElement@ CallbackClickMouse( ICallbackClickMouse@ c ) { @CallMouseClick = c;
                                                                return this; }
    IGUIElement@ AddText( string@ txt, int x, int y, int w, int h, uint c, int fo, int fl ) { @Txt = GUIText( txt, PosX + x, PosY + y, w, h, c, fo, fl );
                                                                                              return this; }
    IGUIElement@ AddText( string@ txt, int x, int y, uint c, int fo, int fl ) { if( not (Image is null) )
                                                                                    @Txt = GUIText( txt, PosX + x, PosY + y, Image.Width, Image.Height, c, fo, fl );
                                                                                return this; }
    IGUIElement@ ChangeText( string@ txt ) { if( not (Txt is null) )
                                                 @Txt.Txt = txt;
                                             return this; }
    IGUIElement@ GetPos( int& X, int& Y ) {    X += PosX;
                                               Y += PosY;
                                               return this; }
    IGUIElement@ DownImage( string@ sprName )
    {
        Sprite spr;
        spr.Load( sprName, PICK_PATH_DEFAULT );
        @DownSpr = spr;
        return this;
    }

    IGUIElement@ Blocking( bool IsBlocking )
    {
        IsBlock = IsBlocking;
        return this;
    }

    IGUIElement@ AnimImage( bool IsDownImage, uint timeNextFrm )
    {
        if( IsDownImage )
        {
            if( not (DownSpr is null) )
            {
                DownSpr.SetAnimation( timeNextFrm );
            }
        }
        else
        {
            if( not (Image is null) )
            {
                Image.SetAnimation( timeNextFrm );
            }
        }
        return this;
    }

    IGUIScroll@ GetScroll()
    {
        GUIScreen@ Screen;
        if( IndexScreen < AllScreens.length() )
        {
            @ Screen = AllScreens[ IndexScreen ];
            if( valid( Screen ) && Screen.Scrolls.length() > ScrollIndex )
            {
                return Screen.Scrolls[ ScrollIndex ];
            }
        }
        return null;
    }

    GUIScrollElements@ GetScrollElements()
    {
        GUIScreen@ Screen;
        if( IndexScreen < AllScreens.length() )
        {
            @ Screen = AllScreens[ IndexScreen ];
            if( valid( Screen ) && Screen.Scrolls.length() > ScrollIndex )
            {
                return Screen.Scrolls[ ScrollIndex ];
            }
        }
        return null;
    }

    IGUIElement@ SetScrollChangeOff( int newValue, IGUIScroll@ Scroll = null )
    {
        if( valid( Scroll ) )
        {
            Scroll.GetIndex( ScrollIndex );
        }
        ScrollOffValue = newValue;
        return this;
    }

    IGUIElement@ SetScrollFlag( int flag, IGUIScroll@ Scroll = null )
    {
        if( valid( Scroll ) )
        {
            Scroll.GetIndex( ScrollIndex );
        }
        ScrollFlags = flag;
        return this;
    }

    IGUIElement@ RollOver( bool isRollOver )
    {
        IsRollOver = isRollOver;
        return this;
    }

    int                  PosX;
    int                  PosY;

    bool                 IsRollOver;
    bool                 IsBlock;
    bool                 IsFirstTime;
    bool                 NoMove;
    bool                 IsLeftMouseDown;
    bool                 IsFocus;
    bool                 OtherRollOff;
    uint                 IndexScreen;

    GUIText@             Txt;
    // int
    Sprite@              Image;
    Sprite@              DownSpr;

    ICallbackClickMouse@ CallMouseClick;
    ICallbackDraw@       CallDraw;
    ICallbackDrawPos@    CallPosDraw;

    uint                 FocusTick;

    uint                 ScrollIndex;
    int                  ScrollFlags;
    int                  ScrollOffValue;
}

class GUIScreen : IGUIScreen
{
    GUIScreen( string@ ImageName, int path, uint index )
    {
        MonitorX = __ScreenWidth / 2;
        MonitorY = __ScreenHeight / 2;
        Width = 0;
        Height = 0;
        if( ImageName.length() > 0 )
        {
            Sprite spr;
            spr.Load( ImageName, path );
            if( not (spr is null) )
                @ScreenImage = spr;
            MonitorX -= spr.Width / 2;
            MonitorY -= spr.Height / 2;
            Width += spr.Width;
            Height += spr.Height;
        }
        else
            @ScreenImage = null;

        LastX = MonitorX;
        LastY = MonitorY;
        Index = index;
        LayerDraw = 4;

        TimeShow = 0;

        IsEscClose = true;
        IsFirstTime = true;
        IsLeftMouseDown = false;
        IsClickNoFocusClose = false;
        IsWarning = false;
        IsSkipClick = false;
        IsOpen = false;

        @CallPosDraw = null;
        @DownScreenImage = null;
        @CallMouseClick = null;
        @CallDraw = null;
        @CallKey = null;
        @CallIsActive = null;
        IsMove = false;
    }

    void Screen_render()
    {
        if( not (DownScreenImage is null) )
        {
            if( IsLeftMouseDown )
            {
                DownScreenImage.Draw( MonitorX, MonitorY );
            }
            else if( not (ScreenImage is null) )
                ScreenImage.Draw( MonitorX, MonitorY );
        }
        else
        {
            if( not (ScreenImage is null) )
                ScreenImage.Draw( MonitorX, MonitorY );
        }
        int endX = MonitorX + Width;
        int endY = MonitorY + Height;
        if( not (CallDraw is null) )
            CallDraw.IDraw();
        if( not (CallPosDraw is null) )
            CallPosDraw.IDraw( MonitorX, MonitorY, endX, endY );
        for( uint i = 0, im = Texts.length(); i < im; i++ )
            Texts[ i ].Draw( MonitorX, MonitorY );
        for( uint i = 0, im = Elements.length(); i < im; i++ )
            Elements[ i ].Render_Element( MonitorX, MonitorY );
        for( uint i = 0, im = Scrolls.length(); i < im; i++ )
            Scrolls[ i ].Scroll_render( MonitorX, MonitorY );
    }

    bool MouseClick( int click, bool downClick )
    {
        if( click == MOUSE_CLICK_LEFT )
            IsLeftMouseDown = downClick;
        for( uint e = 0, em = Elements.length(); e < em; e++ )
            if( IS_COLLISION_MOUSE_ELEMENT( Elements[ e ], this ) && Elements[ e ].MouseClick( click, downClick ) )
                return true;
        for( uint i = 0, im = Scrolls.length(); i < im; i++ )
            if( IS_COLLISION_MOUSE_SCROLL( Scrolls[ i ], this ) && Scrolls[ i ].MouseClick( click, downClick, MonitorX, MonitorY ) )
                return true;
        if( not (CallMouseClick is null) )
            return CallMouseClick.IClickMouse( click, downClick );
        return !IsSkipClick;
    }

    void MouseMove( int x, int y )
    {
        if( IsLeftMouseDown && IsMove )
        {
            int offsX = x - LastX;
            int offsY = y - LastY;
            MonitorX += offsX;
            MonitorY += offsY;
        }
        LastX = x;
        LastY = y;
    }

    void MoveMouseNoFocus()
    {
        IsLeftMouseDown = false;
        for( uint e = 0, em = Elements.length(); e < em; e++ )
        {
            if( !Elements[ e ].IsRollOver )
                Elements[ e ].IsLeftMouseDown = false;
        }
    }

    void Init()
    {
        if( not (CallInit is null) )
            CallInit.Init( IsFirstTime );
        if( IsFirstTime )
        {
            IsFirstTime = false;
        }
        else
        {}

        TimeShow = GetTick();
    }

    bool KeyPress( uint8 key, bool IsDown )
    {
        if( not (CallKey is null) )
            return CallKey.PressKey( key, IsDown );
        return false;
    }

    void Hide()
    {
        if( not (CallHide is null) )
            CallHide.Hide();
    }

    IGUIScreen@ CallbackDraw( ICallbackDraw@ c ) { @CallDraw = c;
                                                   return this; }
    IGUIScreen@ CallbackClickMouse( ICallbackClickMouse@ c ) { @CallMouseClick = c;
                                                               return this; }
    IGUIScreen@ CallbackInit( ICallbackInit@ c ) { @CallInit = c;
                                                   return this; }
    IGUIScreen@ CallbackHide( ICallbackHide@ c ) { @CallHide = c;
                                                   return this; }
    IGUIScreen@ CallbackKey( ICallbackKey@ c ) { @CallKey = c;
                                                 return this; }
    IGUIScreen@ Move( bool move ) { IsMove = move;
                                    return this; }
    IGUIScreen@ Position( int x, int y ) { MonitorX = x;
                                           MonitorY = y;
                                           return this; }
    IGUIScreen@ DrawLayer( uint layer ) { LayerDraw = layer;
                                          return this; }
    IGUIScreen@ AddText( string@ txt, int x, int y, int w, int h, uint c, int fo, int fl ) { Texts.insertLast( @GUIText( txt, MonitorX + x, MonitorY + y, w, h, c, fo, fl ) );
                                                                                             return this; }
    IGUIScreen@ AddText( string@ txt, int x, int y, uint c, int fo, int fl ) { if( not (ScreenImage is null) )
                                                                                   Texts.insertLast( @GUIText( txt, MonitorX + x, MonitorY + y, ScreenImage.Width, ScreenImage.Height, c, fo, fl ) );
                                                                               return this; }
    IGUIScreen@ GetPos( int& X, int& Y ) {     X += MonitorX;
                                               Y += MonitorY;
                                               return this; }
    IGUIScreen@ Resize( int endX, int endY, bool IsFull = true )
    {
        if( IsFull )
        {
            Width = endX;
            Height = endY;
        }
        else
        {
            Width += endX;
            Height += endY;
        }
        return this;
    }

    IGUIScreen@ SetDynamic( ICallbackIsActive@ c )
    {
        if( c is null )
        {
            if( not (CallIsActive is null) )
            {
                int index = DynamicScreens.find( this );
                if( index > 0 )
                {
                    DynamicScreens.removeAt( index );
                }
            }
        }
        else if( CallIsActive is null )
            DynamicScreens.insertLast( this );

        @ CallIsActive = c;
        return this;
    }

    IGUIScreen@ CallbackDrawPos( ICallbackDrawPos@c ) { @CallPosDraw = c;
                                                        return this; }
    IGUIScreen@ DownImage( string@ sprName )
    {
        Sprite spr;
        spr.Load( sprName, PICK_PATH_DEFAULT );
        if( not (spr is null) )
            @DownScreenImage = spr;
        return this;
    }

    // IGUIScreen@ GetElemets	                (IGUIElement@[] es) {for(uint im=Elements.length(), i=0;i<im;i++)  es.insertLast(Elements[i]); return this;}
    // IGUIScreen@ GetBlockElemets	        (IGUIElement@[] es)	{ for(uint im=Elements.length(), i=0;i<im;i++) if(Elements[i].IsBlock) es.insertLast(Elements[i]); return this;}

    IGUIScreen@ AnimImage( bool IsDownImage, uint timeNextFrm )
    {
        if( IsDownImage )
        {
            if( not (DownScreenImage is null) )
            {
                DownScreenImage.SetAnimation( timeNextFrm );
            }
        }
        else
        {
            if( not (ScreenImage is null) )
            {
                ScreenImage.SetAnimation( timeNextFrm );
            }
        }
        return this;
    }

    IGUIScreen@ SetSkipClick( bool IsClose )
    {
        IsSkipClick = IsClose;
        return this;
    }

    IGUIScreen@ EscClose( bool IsClose )
    {
        IsEscClose = IsClose;
        return this;
    }

    IGUIScreen@ ClickNoFocusClose( bool IsClose )
    {
        IsClickNoFocusClose = IsClose;
        return this;
    }

    IGUIElement@ AddElement( string@ ImageName )
    {
        GUIElement e( ImageName, PICK_PATH_DEFAULT, Index, 0 );
        Elements.insertLast( @e );
        e.Init();
        return @e;
    }

    bool IsCloseClickNoFocus()
    {
        return ( IsClickNoFocusClose && ( GetTick() - TimeShow ) >= TIME_NO_CLOSE_SCREEN );
    }

    IGUIScreen@ WarningScreen( bool isWarning )
    {
        IsWarning = isWarning;
        return this;
    }

    IGUIScroll@ AddScroll( int x, int y, int sizeX, int sizeY )
    {
        uint scrollIndex = Scrolls.length();
        GUIScrollElements scroll( x, y, sizeX, sizeY, Index, scrollIndex );
        Scrolls.insertLast( @scroll );
        return @scroll;
    }

    bool opEquals( const GUIScreen& in other )
    {
        return Index == other.Index;
    }

    int                  MonitorX;
    int                  MonitorY;
    int                  Width;
    int                  Height;
    int                  LastX;
    int                  LastY;

    uint                 Index;
    uint                 LayerDraw;
    uint                 TimeShow;

    bool                 IsSkipClick;
    bool                 IsEscClose;
    bool                 IsMove;
    bool                 IsFirstTime;
    bool                 IsLeftMouseDown;
    bool                 IsClickNoFocusClose;
    bool                 IsWarning;
    bool                 IsOpen;
    bool                 IsDynamic;
    Sprite@              DownScreenImage;
    Sprite@              ScreenImage;

    ICallbackDraw@       CallDraw;
    ICallbackDrawPos@    CallPosDraw;
    ICallbackClickMouse@ CallMouseClick;
    ICallbackInit@       CallInit;
    ICallbackHide@       CallHide;
    ICallbackKey@        CallKey;
    ICallbackIsActive@   CallIsActive;

    GUIText@[] Texts;
    GUIElement@[] Elements;
    GUIScrollElements@[] Scrolls;
}

#define CALLBACK_FUNCDEF      0
#define CALLBACK_INTERFACE    1

class GUILoopEvent
{
    ICallbackLoop@ CallLoop;
    FuncDefLoop@   FuncLoop;

    int8           CallbackType;

    uint Run()
    {
        switch( CallbackType )
        {
        case CALLBACK_FUNCDEF:
        {
            TickNextRun = FuncLoop() * GUIOption::LoopStep;
        } break;
        case CALLBACK_INTERFACE:
        {
            TickNextRun = CallLoop.Loop() * GUIOption::LoopStep;
        } break;
        default:
            break;
        }

        return TickNextRun;
    }

    // opCmp

    bool opEquals( const GUILoopEvent& in other )
    {
        return TickNextRun == other.TickNextRun;
    }

    int opCmp( const GUILoopEvent& in other )
    {
        if( TickNextRun > other.TickNextRun )
            return 1;
        else if( TickNextRun < other.TickNextRun )
            return -1;
        return 0;
    }

    uint TickNextRun;
}

GUILoopEvent@[] LoopEvents;

void AddLoopEvent( const uint& in firstCall, ICallbackLoop@ c ) { AddLoopEvent( firstCall, c, null ); }

void AddLoopEvent( const uint& in firstCall, ICallbackLoop@ c, FuncDefLoop@ f )
{
    GUILoopEvent newEvent;

    if( c is null )
    {
        if( f is null )
            return;

        newEvent.CallbackType = CALLBACK_FUNCDEF;
        @ newEvent.FuncLoop = f;
        @ newEvent.CallLoop = null;
    }
    else
    {
        newEvent.CallbackType = CALLBACK_INTERFACE;
        @ newEvent.FuncLoop = null;
        @ newEvent.CallLoop = c;
    }

    if( firstCall == 0 )
        newEvent.Run();
    else
        newEvent.TickNextRun = firstCall * GUIOption::LoopStep;

    if( newEvent.TickNextRun > 0 )
    {
        LoopEvents.insertLast( newEvent );
        LoopEvents.sortAsc();
    }
}

uint CheckDynamicTick = GUIOption::CheckDynamicScreenMs * GUIOption::LoopStep;

uint GUILoop()
{
    CheckDynamicTick--;
    if( CheckDynamicTick == 0 )
    {
        for( uint i = 0, im = DynamicScreens.length(); i < im; i++ )
            if( valid( DynamicScreens[ i ].CallIsActive ) )
            {
                if( DynamicScreens[ i ].CallIsActive.IsActive() )
                {
                    GUI_ShowScreen( DynamicScreens[ i ] );
                }
                else
                {
                    GUI_HideScreen( DynamicScreens[ i ] );
                }
            }
        CheckDynamicTick = GUIOption::CheckDynamicScreenMs * GUIOption::LoopStep;
    }

    bool isSort = false;

    {
        uint im = LoopEvents.length();
        if( im > 0 )
        {
            const uint firstTick = LoopEvents[ 0 ].TickNextRun;

            for( uint i = 0; i < im; i++ )
            {
                if( firstTick != LoopEvents[ i ].TickNextRun )
                {
                    LoopEvents[ i ].TickNextRun -= GUIOption::LoopStep;
                    continue;
                }

                if( LoopEvents[ i ].TickNextRun == 0 )
                {
                    if( LoopEvents[ i ].Run() == 0 )
                    {
                        LoopEvents.removeAt( i-- );
                        im--;
                    }
                    isSort = true;
                }
                else
                    LoopEvents[ i ].TickNextRun -= GUIOption::LoopStep;
            }
        }
    }

    if( isSort )
        LoopEvents.sortAsc();

    return GUIOption::LoopStep;
}

class GUIText
{
    GUIText( string@ txt, int x, int y, int w, int h, uint c, int fo, int fl )
    {
        @Txt = txt;
        offX = x;
        offY = y;
        Width = w;
        Height = h;
        Color = c;
        Font = fo;
        Flags = fl;
    }

    void Draw( int x, int y )
    {
        DrawText( Txt, x + offX, y + offY, Width, Height, Color, Font, Flags );
    }

    string@ Txt;
    int     offX;
    int     offY;
    int     Width;
    int     Height;
    uint    Color;
    int     Font;
    int     Flags;
}

class GUIScrollElements : IGUIScroll
{
    GUIScrollElements( int x, int y, uint sizeX, uint sizeY, uint screenIndex, uint index )
    {
        MonitorX = x;
        MonitorY = y;
        Width = sizeX;
        Height = sizeY;

        Index = index;

        CurrentOffX = 0;
        CurrentOffY = 0;

        MinOffX = 0;
        MinOffY = 0;
        MaxOffX = 0;
        MaxOffY = 0;

        ScreenIndex = screenIndex;
    }

    IGUIElement@ AddElement( string@ ImageName )
    {
        GUIElement e( ImageName, PICK_PATH_DEFAULT, ScreenIndex, Index, SEF_NONE );
        Elements.insertLast( @e );
        e.Init();
        return @e;
    }

    void Scroll_render( int screenX, int screenY )
    {
        for( uint i = 0, im = Elements.length(); i < im; i++ )
        {
            GUIElement@ e = Elements[ i ];
            if( valid( e ) )
            {
                if( IS_COLLISION( e.PosX, e.PosY, CurrentOffX, CurrentOffY, Width, Height ) )
                {
                    if( IS_COLLISION( e.PosX + e.Image.Width, e.PosY + e.Image.Height, CurrentOffX, CurrentOffY, Width, Height ) )
                    {
                        e.Render_Element( MonitorX + screenX - CurrentOffX, MonitorY + screenY - CurrentOffY );
                    }
                }
            }
        }
    }

    bool MouseClick( int click, bool downClick, int screenX, int screenY )
    {
        if( IsWheelScroll )
        {
            if( click == MOUSE_CLICK_WHEEL_UP )
            {
                CurrentOffY -= ScrollWhellPix;
                if( CurrentOffY < MinOffY )
                    CurrentOffY = MinOffY;
                else if( CurrentOffY > MaxOffY )
                    CurrentOffY = MaxOffY;
                return true;
            }
            else if( click == MOUSE_CLICK_WHEEL_DOWN )
            {
                CurrentOffY += ScrollWhellPix;
                if( CurrentOffY < MinOffY )
                    CurrentOffY = MinOffY;
                else if( CurrentOffY > MaxOffY )
                    CurrentOffY = MaxOffY;
                return true;
            }
        }
        for( uint i = 0, im = Elements.length(); i < im; i++ )
        {
            GUIElement@ e = Elements[ i ];
            if( valid( e ) )
            {
                if( IS_COLLISION( e.PosX, e.PosY, CurrentOffX, CurrentOffY, Width, Height ) && IS_COLLISION( e.PosX + e.Image.Width, e.PosY + e.Image.Height, CurrentOffX, CurrentOffY, Width, Height ) && IS_COLLISION( __MouseX, __MouseY, MonitorX + screenX - CurrentOffX + e.PosX, MonitorY + screenY - CurrentOffY + e.PosY, e.Image.Width, e.Image.Height ) && e.MouseClick( click, downClick ) )
                {
                    return true;
                }
            }
        }
        return false;
    }

    IGUIScreen@ GetScreen()
    {
        if( ScreenIndex < AllScreens.length() )
            return AllScreens[ ScreenIndex ];
        return null;
    }

    IGUIScroll@ GetIndex( uint& index )
    {
        index = Index;
        return this;
    }

    IGUIScroll@ SetWheelScroll( uint pix )
    {
        IsWheelScroll = true;
        ScrollWhellPix = pix;
        return this;
    }

    IGUIScroll@ SetBorderScroll( int minOffX, int minOffY, int maxOffX, int maxOffY )
    {
        MinOffX = minOffX;
        MinOffY = minOffY;
        MaxOffX = maxOffX;
        MaxOffY = maxOffY;
        return this;
    }

    int  MonitorX;
    int  MonitorY;
    int  Width;
    int  Height;

    int  CurrentOffX;
    int  CurrentOffY;
    int  MinOffX;
    int  MinOffY;
    int  MaxOffX;
    int  MaxOffY;

    uint ScreenIndex;
    uint Index;

    bool IsWheelScroll;
    uint ScrollWhellPix;

    GUIElement@[] Elements;
}

IGUIScreen@ GUI_CreateScreen( string@ sprName, uint index )
{
    GUIScreen screen( sprName, PICK_PATH_DEFAULT, index );
    if( not (screen is null) )
    {
        @AllScreens[ index ] = screen;
        screen.Init();
    }
    return @screen;
}

IGUIScreen@ GUI_ShowScreen( uint index )
{
    if( index >= AllScreens.length() )
        return null;
    GUIScreen@ screen = AllScreens[ index ];
    return GUI_ShowScreen( screen );
}

IGUIScreen@ GUI_HideScreen( uint index )
{
    if( index >= AllScreens.length() )
        return null;
    GUIScreen@ screen = AllScreens[ index ];
    return GUI_HideScreen( screen );
}

IGUIScreen@ GUI_ShowScreen( GUIScreen@ screen )
{
    if( not (screen is null) && !screen.IsOpen )
    {
        screen.IsOpen = true;
        ActivScreens.insertLast( screen );
        screen.Init();
        if( screen.IsWarning )
            ActivWarningScreen++;
    }
    return screen;
}

IGUIScreen@ GUI_HideScreen( GUIScreen@ screen )
{
    if( not (screen is null) && screen.IsOpen )
    {
        for( uint i = 0, im = ActivScreens.length(); i < im; i++ )
            if( ActivScreens[ i ] is screen )
            {
                ActivScreens.removeAt( i );
                screen.Hide();
                if( screen.IsWarning )
                    ActivWarningScreen--;
                screen.IsOpen = false;
                return screen;
            }
    }
    return screen;
}

void GUI_render( uint layer )
{
    for( uint i = 0, im = ActivScreens.length(); i < im; i++ )
        if( ActivScreens[ i ].LayerDraw == layer )
            ActivScreens[ i ].Screen_render();

    for( uint i = 0; i < DrawEvents.length(); i++ )
        DrawEvents[ i ].IDraw( layer );
}

bool GUI_mouse( int click, bool downClick )
{
    if( ActivWarningScreen > 0 )
    {
        for( uint i = ActivScreens.length() == 0 ? 0 : ActivScreens.length() - 1; 0 <= i; i-- )
        {
            if( ActivScreens[ i ].IsWarning )
            {
                GUIScreen@ tmpScreen = ActivScreens[ i ];
                @ActivScreens[ i ] = ActivScreens[ ActivScreens.length() - 1 ];
                @ActivScreens[ ActivScreens.length() - 1 ] = tmpScreen;
                break;
            }
        }
    }

    GUIScreen@ main = GetMainActivScreen();
    bool       IsTrue = false,
               isValidMain = not (main is null);
    GUIScreen@[] HideScreens;

    for( uint i = 0, iEnd = MouseClickEvents.length(); i < iEnd; i++ )
        if( MouseClickEvents[ i ].IEClickMouse( click, downClick ) )
        {
            IsTrue = true;
            break;
        }

    if( isValidMain )
    {
        if( main.IsWarning )
        {
            return main.MouseClick( click, downClick );
        }
        if( IS_COLLISION_MOUSE_SCREEN( main ) )
        {
            IsTrue = main.MouseClick( click, downClick );
        }
        else if( main.IsCloseClickNoFocus() )
            HideScreens.insertLast( main );
    }

    if( downClick )
    {
        for( uint i = 0, im = ActivScreens.length(); i < im; i++ )
        {
            if( IS_COLLISION_MOUSE_SCREEN( ActivScreens[ i ] ) )
            {
                if( !IsTrue && ( !isValidMain || ( isValidMain && main.Index != ActivScreens[ i ].Index ) ) )
                {
                    GUIScreen@ tmpScreen = ActivScreens[ i ];
                    @ActivScreens[ i ] = ActivScreens[ im - 1 ];
                    @ActivScreens[ im - 1 ] = tmpScreen;
                    IsTrue = tmpScreen.MouseClick( click, downClick );
                }
            }
            else if( ActivScreens[ i ].IsCloseClickNoFocus() )
                HideScreens.insertLast( ActivScreens[ i ] );
            im = ActivScreens.length();
        }
        for( uint i = 0, im = HideScreens.length(); i < im; i++ )
        {
            GUI_HideScreen( HideScreens[ i ].Index );
        }
    }
    return IsTrue;
}

void GUI_mouse_move( int x, int y )
{
    GUIScreen@ main = GetMainActivScreen();
    if( not (main is null) && IS_COLLISION_MOUSE_SCREEN( main ) )
    {
        main.MouseMove( x, y );
    }

    for( uint i = 0, im = ActivScreens.length(); i < im; i++ )
    {
        if( not IS_COLLISION_MOUSE_SCREEN( main ) )
            ActivScreens[ i ].MoveMouseNoFocus();
    }

    for( uint i = 0, iEnd = MouseMoveEvents.length(); i < iEnd; i++ )
        if( valid( MouseMoveEvents[ i ] ) )
            MouseMoveEvents[ i ].IMouseMove( x, y );
}

void GUI_Init()
{
    AllScreens.resize( MAPPER_IFACE_END );
    @Keyboard = CKeyboard();
}

bool GUI_key_down( uint8 key )
{
    if( key >= SIZE_KEYBOARD || (Keyboard is null) )
        return false;
    return Keyboard.KeyDown( key );
}

bool GUI_key_up( uint8 key )
{
    if( key >= SIZE_KEYBOARD || ( (Keyboard is null) ) )
        return false;

    return Keyboard.KeyUp( key );
}

bool GUI_KeyPressText( uint8 key, string& text )
{
    if( key >= SIZE_KEYBOARD || ( (Keyboard is null) ) )
        return false;

    return Keyboard.Text( key, text );
}

bool GUI_IsKeyPress( uint8 key )
{
    if( key >= SIZE_KEYBOARD || ( (Keyboard is null) ) )
        return false;

    return Keyboard.IsKeyPress( key );
}

bool AddHotKey( ICallbacHotKey@ c, string@ txt, uint8 key )
{
    if( not (Keyboard is null) )
        return Keyboard.AddHotKey( c, txt, key );
    Message( "Клавиатура отсутствует, ХотКей не создан." );
    Log( "Клавиатура отсутствует, ХотКей не создан." );
    return false;
}

bool AddHotKey( ICallbacHotKey@ c, string@ txt, uint8 key, uint8 IsKey )
{
    if( not (Keyboard is null) )
        return Keyboard.AddHotKey( c, txt, key, IsKey );
    Message( "Клавиатура отсутствует, ХотКей не создан." );
    Log( "Клавиатура отсутствует, ХотКей не создан." );
    return false;
}

void GUI_DeleteScreen( uint index )
{
    @AllScreens[ index ] = null;
}

void AddMouseMoveEvent( ICallbackMouseMove@ c )
{
    MouseMoveEvents.insertLast( c );
}

void AddDrawEvent( IEventDraw@ c )
{
    DrawEvents.insertLast( c );
}

void GUI_render_map()
{
    for( uint i = 0, iMax = DrawMapEvents.length(); i < iMax; i++ )
        DrawMapEvents[ i ].IDrawMap();
}

bool GUI_console_message( string& message )
{
    __ConsoleActive = !__ConsoleActive;
    return false;
}

void AddDrawMapEvent( IEventDrawMap@ c )
{
    DrawMapEvents.insertLast( c );
}

void AddMouseClickEvent( IEventClickMouse@ c )
{
    MouseClickEvents.insertLast( c );
}

bool IsMonitorScreen( int x, int y )
{
    for( uint i = 0, im = ActivScreens.length(); i < im; i++ )
    {
        if( IS_COLLISION_SCREEN( x, y, ActivScreens[ i ] ) )
            return true;
    }
    return false;
}

void AddPressKeyEvent( ICallbackKey@ c )
{
    PressKeyEvents.insertLast( c );
}

const uint __GetCheckDynamicScreenMs()
{
    return GUIOption::CheckDynamicScreenMs;
}

const uint __GetLoopStep()
{
    return GUIOption::LoopStep;
}
